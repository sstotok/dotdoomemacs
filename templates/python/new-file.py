#!/usr/bin/env python3
#-*- coding:utf-8 mode:python -*-
#

import sys
import os
import logging
import subprocess

from datetime import datetime

class CBaseException(Exception): pass
class CCommandFail(CBaseException): pass
class CCommandNotFound(CBaseException): pass

# version info
__version_info__ = (0, 0, 1)
__version__      = '.'.join(str(c) for c in __version_info__)
__progname_version__ = __file__ + ' Ver ' + __version__

#
class ClassName(object):
    # External program
    CMD_LS = 'ls'
    EXES = (CMD_LS, )      # list of external executable program
    #
    def __init__(self, **kwargs):
        self.verbose        = self.set_verbosity(kwargs.get('verbose', logging.NOTSET))  # integer
        self.outputfile     = os.path.join(os.path.abspath(os.getcwd()), kwargs.get('outputfile'))
        self.now            = datetime.now() # self.now.strftime('%d-%b-%Y %H:%M:%S')

        # setup logger
        formatter = logging.Formatter('%(funcName)s:%(lineno)d %(message)s')
        self.logger = logging.getLogger('YourProgram')
        self.logger.setLevel(self.verbose)
        # output log to console
        consoleHandler = logging.StreamHandler(sys.stdout)
        consoleHandler.setFormatter(formatter)
        self.logger.addHandler(consoleHandler)
        # output log to file
        logFile = os.path.join(os.path.abspath(os.getcwd()), 'yourprogram_{}.log'.format(self.now.strftime('%Y%m%d_%H%M%S')))
        fileHandler = logging.FileHandler(logFile)
        fileHandler.setFormatter(formatter)
        self.logger.addHandler(fileHandler)
        # this may not be printed out due to ... too early??
        self.logger.info('INFO:: Generated by ' + os.path.basename(__file__) + ' ' + __version__ + ' on ' + self.now.strftime('%d-%b-%Y %H:%M:%S'))
        self.logger.debug('DEBUG:: Output file: {}'.format(self.outputfile))
        self.logger.debug('DEBUG:: Logging file: {}'.format(logFile))

        # check executables
        try:
            self.check_executables()
        except Exception as e:
            self.logger.critical('CRITICAL:: External program not found. Exit!!\n{}'.format(e))
            raise

    #
    def set_verbosity(self, verbose):
        """
        Set verbosity.
        usage:  DEBUG for developer, and INFO for user
        ------------------------------------------
          Level        Numeric value  User options
        ------------------------------------------
         CRITICAL           50
         ERROR              40
         WARNING            30
         INFO               20            -v
         DEBUG              10            -vv
         NOTSET              0
        -------------------------------------------
        """
        if verbose >= 2:        # -vv
            return logging.DEBUG
        elif verbose == 1:      # -v
            return logging.INFO
        else:
            return logging.NOTSET

    #
    def check_executables(self):
        for exe in self.EXES:
            exepath = self.which(exe)
            if exepath is None:
                raise CCommandNotFound('"{}" not found in PATH'.format(exe))

    #
    def which(self, program):
        '''
        similar to unix 'which' command
        '''
        def is_exe(fpath):
            return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
        #
        fpath, fname = os.path.split(program)
        if fpath:
            if is_exe(program):
                return program
        else:
            for path in os.environ["PATH"].split(os.pathsep):
                exe_file = os.path.join(path, program)
                if is_exe(exe_file):
                    return exe_file
        #
        return None
    #
    def run_commands(self, cmds):
        '''
        Parameter 'cmds' is a list of commands including it's parameters.
        '''
        for cmd in cmds:
            try:
                p = subprocess.Popen(cmd, shell=True,
                                     stdin=subprocess.PIPE,
                                     stdout=subprocess.PIPE,
                                     stderr=subprocess.PIPE)
            except OSError:
                raise CCommandFail('Cmd failed [OSError] {}'.format(cmd))
            except:
                raise CCommandFail('Cmd failed [Unknown Error]: {}'.format(cmd))

            #
            # p.wait()
            out, err = p.communicate()
            if p.returncode:
                raise CCommandFail('Cmd {} return error {}.\n{}'.format(cmd, p.returncode, err.decode('ascii')))
            #
            return (out, err)

    #
    def execute_main(self):
        try:
            out, err = self.run_commands([self.CMD_LS + ' -alF'])
            self.logger.debug('DEBUG:: out:\n{}'.format(out.decode('ascii')))
            self.logger.debug('DEBUG:: err:\n{}'.format(err.decode('ascii')))
        except CCommandFail as e:
            self.logger.error('ERROR:: CCommandFail Exception\n{}'.format(e))
        except Exception as e:
            self.logger.error('ERROR:: Exception\n{}'.format(e))

# main
if __name__ == '__main__':
    import argparse

    # setup parser
    parser = argparse.ArgumentParser(description='Program Description')
    parser.add_argument('--version', action='version', version=__progname_version__)
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help='increase verbosity. Specify multiple time for increased diagnostic output.')
    parser.add_argument('-o', '--out', dest='outputfile', required=True, help='output filename')

    args = parser.parse_args()
    opts = {'verbose'         : args.verbose,
            'outputfile'      : args.outputfile,
            }

    ClassName(**opts).execute_main()
